Инструментарий для ведения непрерывной верификации
--------------------------------------------------

1. Предварительная настройка инструментария.
1.1. Установка инструментария.
1.1.1. Проверить наличие требуемых зависимостей из инструкции docs/tools.txt.
1.1.2. Выполнить установку: make -j2 DEPLOY_DIR=<рабочая директория>.
1.1.3. Развернуть web-интерфейс для отображения результатов согласно инструкции docs/web_interface.txt.
1.1.4. (Опционально) Развернуть облако для параллельного решения задач на нескольких машинах согласно инструкции docs/verification_cloud.txt.

1.2. Настройка контрольных групп.
1.2.1. Подключение контрольных групп.
По умолчанию для Ubuntu 16.04 и выше контрольные группы уже должны быть установлены, поэтому данный шаг можно пропустить.
Если команда
cat /proc/mounts | grep "cgroup"
ничего не выдает, то для установки контрольных групп необходимо выполнить:
sudo mount -t cgroup none /sys/fs/cgroup
1.2.2. Настройка прав на использование контрольх групп.
sudo chmod o+wt '/sys/fs/cgroup/cpuset/'
sudo chmod o+wt '/sys/fs/cgroup/freezer/'
sudo chmod o+wt '/sys/fs/cgroup/cpu,cpuacct/'
sudo chmod o+wt '/sys/fs/cgroup/memory/'
sudo chmod o+wt '/sys/fs/cgroup/cpu,cpuacct/user.slice'
sudo chmod o+wt '/sys/fs/cgroup/memory/user.slice'
sudo chmod o+wt '/sys/fs/cgroup'
Данный шаг необходимо выполнять каждый раз после перезагрузки машины.

1.3 Настройка свопа.
Базовый вариант.
1.3.1. Добавить "swapaccount=1" к значению переменной GRUB_CMDLINE_LINUX_DEFAULT в файле /etc/default/grub.
1.3.2. Выполнить sudo update-grub.
1.3.3. Перезагрузить машину.
1.3.4. Проверить наличие свопа в контрольных группах.
В директории контрольной группы подсистемы memory (по умолчанию /sys/fs/cgroup/memory/) должны присутствовать файлы вида memory.memsw.*. Если файлов нет, то потребуется альтернативный вариант настройки.
Альтернативный вариант: отключать своп командой
sudo swapoff -a
каждый раз после перезагрузки.

1.4. Добавить необходимую конфигурацию.
Пусть требуется проверить систему с названием system_id.
Для добавления конфигурации необходимо в каждой из специальных директорий создать поддиректорию system_id, в которую потребуется добавить конфигурационные файлы.
Специальные директории:
- entrypoints (содержит описание генерируемых точек входа для верифицируемой системы) — добавляются файлы, описывающие множество точек входа и проверяемую подсистему (по шаблону);
- rules (содержит модели проверяемых правил корректности) – для каждого проверяемого правила могут потребоваться, например, С-файлы, которые будут добавлены в процесс сборки указанной подсистемы;
- patches/sources (содержит патчи, которые необходимы для успешной сборки верифицируемой системы) – требуется добавить данные патчи при необходимости;
- patches/preparation (содержит конфигурацию для шага подготовки системы к верификации) – требуется добавить файл cong.json по шаблону;
- verifier_files/options (содержит конфигурацию для инструментов верификации) – при необходимости данные опции могут быть изменены;
- docs (содержит документацию) – при необходимости добавляется описание особенностей верификации данной подсистемы.
Таким образом, полностью сконфигурированный инструментарий может иметь следующий вид:
-entrypoints
--system_id
---subsystem_1.json
...
---subsystem_k.json
-rules
--system_id
---common.h (шаблонный файл, может быть изменен)
---rule_1.c
...
---rule_n.c
-patches
--sources
---system_id
----build.patch (применяется для успешной сборки системы)
----verification.patch (применяется для успешной верификации системы)
--preparation
---system_id
----conf.json
В данном случае задачу верификации системы system_id можно декомпозировать на задачу верификации подсистем subsystem_1, ..., subsystem_k (в частности подсистема может совпадать со всей проверяемой системой), в каждой из которых задано некоторое множество точек входа.
При это верификацию можно вести относительно либо 3-х встроенных правил корректности:
 - sync:races – правило для проверки отсутствия состояний гонки по данным;
 - sync:deadlocks – правило для проверки отсутствия ситуаций взаимных блокировок;
 - smg – правило для проверки корректного использования памяти;
либо относительно заданных правил корректности rule_1, ..., rule_n.


2. Запуск верификации.

2.1. Конфигурируемая проверка системы.
Цель - проверить заданную систему system_id, разбив ее на подсистемы subsystem_1, ..., subsystem_k, относительно правил корректности rule_1, ..., rule_n.

Предварительно необходимо создать конфигурацию по шаблону configs/example.json.
При задании конфигурации следует обратить внимание на следующие обязательные поля:
 - Builder: make command – команда сборки системы;
 - sources: branch – ветка в репозитории системы;
 - sources: patches – список патчей, которые последовательно должны быть применены к исходному коду для успешной верификации (в примере [verification.patch]);
 - sources: build patch – патч, который необходимо применить для успешной сборки (в примере build.patch);
 - Preparator: source dir – директория с исходным кодом системы;
 - Preparator: extra options – дополнительные опции, которые будут использоваться при компиляции команд сборки;
 - Preparator: filter black list – шаблоны для исключения команд сборки;
 - Launcher: scheduler – планировщик (local – решение задания на локальной машине, cloud – решение задания в облаке (облако должно быть настроено – см. инструкцию docs/verification_cloud.txt));
 - Launcher: resource limits: CPU time – ограничение на процессорное время на один запуск верификатора в секундах;
 - Launcher: resource limits: memory size – ограничение на оперативную память на один запуск верификатора в GB;
 - Launcher: resource limits: number of cores – ограничение на число ядер процессора на один запуск верификатора;
 - Launcher: backup write – флаг, отвечающий за создание резервной копии для уже полученных результатов (по умолчанию выключен);
 - Launcher: backup read – флаг, отвечающий за чтение ранее полученных результатов из резервной копии (по умолчанию выключен);
 - cloud: master – адрес машины, на которой развёрнуто облако (требуется только при решении задач на облаке);
 - entrypoints desc – список файлов с описанием проверяемых точек входа (в примере subsystem_1, ..., subsystem_k);
 - rules – список проверяемых правил (в примере rule_1, ..., rule_n);
 - callers – список проверяемых точек входа (если данный параметр задан, то все остальные точки входа, описанные в entrypoints desc, будут проигнорированы);
 - commits – список проверяемых коммитов (если данный параметр задан, то будут проверены только обработчики, релевантные указанным коммитам, остальные будут проигнорированы); тег не совместим с тегом callers;
 - system – идентификатор системы (в примере system_id)

При проверке коммитов релевантность обработчика определяется следующим образом.
Для каждого коммита выявляется список функций, в которых выполнялись изменения, после чего находятся все обработчики, из которых данные функции могут вызываться.
Если полученный список функций пуст, то будут проверены все обработчики из подсистем, которые содержат измененные файлы.
Однако следует помнить, что не все зависимости могут быть отслежены таким образом, поэтому для более точной проверки можно либо непосредственно задать список обработчиков (тег callers), либо проверять все обработчики из затронутых коммитом подсистем.

Примечание: при задании ограничения на оперативную память (число ядер) следует учитывать, что оно должно быть меньше всей доступной оперативной памяти (числа ядер) на целевой машине. При этом параллельно будут запускаться N верификаторов, где
N = min(<доступная оперативная память>/<ограничение на оперативную память>, <доступное число ядер>/<ограничение на число ядер>) для сокращения астрономического времени верификации.

Если запуск подразумевает решение большого количества подзадач (их число отображается в логе «Launcher: INFO: Expected number of verifier launches is X», где X – число решаемых подзадач), исчисляемого сотнями, то запуск может занять довольно много времени и рекомендуется создавать резервную копию уже полученных результатов (посредством задания в конфигурации флага «Launcher: backup write»).
В данном случае если запуск верификации завершится некорректно, то информацию об уже завершенных запусках можно найти в файле backup_<название конфигурации>_<временная метка>.csv.
Для продолжения решения только оставшихся подзадач необходимо не удалять рабочую директорию («work_dir») и запустить ту же самую конфигурацию, установив флаг «Launcher: backup read» для считывания резервной копии.
При этом следует помнить, что при таком восстановлении части результата некоторые измерения ресурсов могут быть не точны (например, не удастся вычислить точное полное время работы скрипта).

Запуск производится посредством выполнения скрипта:
scripts/launcher.py --config <файлы с конфигурацией>
Если задано несколько конфигурационных файлов, то их верификация будет производиться последовательно.
Результатом запуска является архив с результатами results/results_<название конфигурации>_<временная метка>.zip.

2.2. Непрерывная проверка изменений в системе.
Цель – проверять каждый новый коммит в репозиторий системы по уже заданным конфигурациям.

Пусть имеется несколько конфигураций для инструментария config_1.json, ..., config_m.json, которые были получены на предыдущем шаге и проверены.

Для того, чтобы повторять их проверку на каждом новом коммите, необходимо задать общую конфигурацию по шаблону configs/auto.json, добавив туда данные по репозиторию, конфигурации config_1.json, ..., config_m.json и адреса электронной почты для рассылок уведомлений (необязательно).

Запуск автоматической проверки изменений осуществляется командой:
./scripts/auto_check.py -c <общая конфигурация>

3. Визуализация результата.

Предполагается, что web-интерфейс развернут (см. инструкцию docs/web_interface.txt) и известен хост <host> (по умолчанию 127.0.0.1) и порт <port>.

Для визуализации результатов необходимо выполнить следующие действия:
3.1. Получить номер отчета в web-интерфейсе. Номер задаётся в виде натурального числа. Если номер <id> уже имеется, то данный шаг можно пропустить и перейти на страницу отчета (<host>:<port>/jobs/<id>).
В противном случае потребуется открыть web-интерфейс (<host>:<port>), ввести имя пользователя и пароль, выбрать любой узел (нажать на ссылку) из появившегося дерева (столбец «Title»), выполнить действие «Make copy» - слева вверху, ввести название нового отчета (столбец «Title») и нажать «Save». После этого web-интерфейс перенаправит на страницу созданного отчета, его номер можно получить из адреса страницы (<host>:<port>/jobs/<id>).
3.2. Загрузить архив с результатами.
Архив, полученный на предыдущем этапе, необходимо загрузить на странице созданного отчета (<host>:<port>/jobs/<id>) web-интерфейса с помощью кнопки "Upload reports" - третья слева.
Для того чтобы автоматически загрузить архив во время верификации, необходимо:
 - создать отчет и получить его идентификатор (Identifier на странице отчета);
 - добавить в конфигурацию инструментария:
  "uploader": {
    "upload results": true,
    "identifier": "<идентификатор отчета>",
    "parent id": "true|false",
    "server": "<host>:<port>",
    "user": "<пользователь в web-интерфейсе, создавший отчет>",
    "password": "<пароль пользователя>"
  }
Если параметр «parent id» установлен в true, то для загрузки результатов будет создан новый отчет, который является потомком заданного (с помощью identifier). В противном случае результаты загружаются непосредственно в заданный отчет, при этом если с данным идентификатором ранее уже создавался отчет, то данная операция его сотрет.
После этого можно производить верификацию стандартным способом (см. пункт 2).

После загрузки на странице отчета появятся следующие секции:
 - «Unsafes» – ссылка на список найденных трасс ошибок;
 - «Safes» – ссылка на список доказательств корректности;
 - «Unknowns» – ссылка на список неуспешных завершений верификатора и других компонентов;
 - «Consumed resources» – таблица с затраченными ресурсами.

В каждом из списков для тройки <подсистема («Subsystem»), обработчик («Verification object»), правило корректности («Rule specification»)> представлена ссылка на более подробное описание (трасса ошибки / доказательство корректности / причина неуспешного завершения) и имеется некоторая дополнительная информация:
 - version – версия проверяемой системы;
 - Verifiers: CPU time | Wall time | RAM – ресурсы, потраченные верификатором на получение данного результата;
 - Traces – число найденных трасс ошибок с помощью инструмента (Initial) и число трасс после фильтрации (Filtered) – только для трасс ошибок;
 - Found all traces – показывает, были ли найдены все трассы ошибок для данной тройки, или нет – только для трасс ошибок;
 - Filtering time – процессорное время выполнения фильтрации в секундах – только для трасс ошибок;
 - Id – идентификатор трассы ошибки (для различия трасс, относящихся к одной тройке) – только для трасс ошибок;
 - Coverage – процент покрытия по строкам (Lines) и по функциям (Functions) в рамках данной тройки (то есть покрытие, которое данный обработчик обеспечивает в данной подсистеме) – только для доказательств корректности;
 - Relevancy – показывает, является ли проверяемое правило релевантным в рамках выбранного обработчика – только для доказательств корректности.

Для доказательств корректности на данный момент дополнительная информация не предоставляется.
Для каждого неуспешного завершения верификатора указывается соответствующая причина (например, «TIMEOUT» – исчерпание ограничения на процессорное время) и лог инструмента верификации.
Для каждой трассы ошибки предоставляется визуализация, которая предназначена для того, чтобы человеку было удобнее провести анализ и определить, соответствует ли она реальной ошибке в коде или является следствием ложного сообщения об ошибке. Для получения статистики по всему запуску рекомендуется создавать оценки (кнопка «Сreate lightweight mark»), которые будут автоматически применены при загрузке новых результатов (например, с более новой версией ядра), что может существенно упростить их анализ. Для этого необходимо указать вердикт («Bug» – истинная ошибка, «False positive» – ложное сообщение об ошибке, «Unknown» – неизвестно), статус исправления ошибки («Status») и причину ложного сообщения об ошибке («Tags»). Если в базе данных нет требуемой причины, то ее необходимо создать на странице Menu->Tags->Unsafe, далее либо «Create new root tag», либо «Create child».
После выполнения подобной разметки трасс ошибок на странице отчета в секции «Unsafes» появится статистика размеченных трасс.

Таблица с затраченными ресурсами содержит информацию по работе каждого компонента:
 - CPU time – процессорное время в секундах;
 - Memory – максимальный объем используемой компонентом оперативной памяти;
 - Wall time – астрономическое время работы компонента.
По умолчанию имеются следующие компоненты:
 - Core – суммарное количество затраченных ресурсов на весь процесс верификации;
 - Builder – отвечает за сборку исходного кода и извлечение команд сборки;
 - Qualifier – отвечает за выявление релевантных для указанных коммитов обработчиков (используется только если задан тег commits);
 - Preparator – отвечает за подготовку верификационных задач для каждой пары <подсистема, правило>;
 - CPAchecker – статический верификатор, который решает подготовленные задачи для каждой тройки <подсистема, правило, обработчик> (астрономическое время компонента не учитывает параллельные запуски);
 - MEA – отвечает за фильтрацию трасс ошибок;
 - Exporter – отвечает за подготовку финального отчета;
 - Launcher – отвечает за запуск всех остальных компонентов.

Если какой-либо из компонентов инструментария завершился с допустимыми проблемами (например, несколько команд сборки не было обработано), то в секции Unknowns будут присутствовать логи падений данных компонентов.

